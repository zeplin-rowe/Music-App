{"version":3,"sources":["../src/telemetry.ts","../src/isomorphicAtob.ts","../src/keys.ts","../src/underscore.ts","../src/telemetry/throttler.ts","../src/telemetry/collector.ts","../src/telemetry/events/component-mounted.ts","../src/telemetry/events/method-called.ts","../src/telemetry/events/framework-metadata.ts","../src/telemetry/events/theme-usage.ts"],"sourcesContent":["export { TelemetryCollector } from './telemetry/collector';\nexport type { TelemetryCollectorOptions } from './telemetry/types';\n\nexport * from './telemetry/events';\n","/**\n * A function that decodes a string of data which has been encoded using base-64 encoding.\n * Uses `atob` if available, otherwise uses `Buffer` from `global`. If neither are available, returns the data as-is.\n */\nexport const isomorphicAtob = (data: string) => {\n  if (typeof atob !== 'undefined' && typeof atob === 'function') {\n    return atob(data);\n  } else if (typeof global !== 'undefined' && global.Buffer) {\n    return new global.Buffer(data, 'base64').toString();\n  }\n  return data;\n};\n","import type { PublishableKey } from '@clerk/types';\n\nimport { DEV_OR_STAGING_SUFFIXES, LEGACY_DEV_INSTANCE_SUFFIXES } from './constants';\nimport { isomorphicAtob } from './isomorphicAtob';\nimport { isomorphicBtoa } from './isomorphicBtoa';\n\n/**\n * Configuration options for parsing publishable keys.\n */\ntype ParsePublishableKeyOptions = {\n  /** Whether to throw an error if parsing fails */\n  fatal?: boolean;\n  /** Custom domain to use for satellite instances */\n  domain?: string;\n  /** Proxy URL to use instead of the decoded frontend API */\n  proxyUrl?: string;\n  /** Whether this is a satellite instance */\n  isSatellite?: boolean;\n};\n\n/** Prefix used for production publishable keys */\nconst PUBLISHABLE_KEY_LIVE_PREFIX = 'pk_live_';\n\n/** Prefix used for development publishable keys */\nconst PUBLISHABLE_KEY_TEST_PREFIX = 'pk_test_';\n\n/**\n * Regular expression that matches development frontend API keys.\n * Matches patterns like: foo-bar-13.clerk.accounts.dev.\n */\nconst PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\\.clerk\\.accounts([a-z.]*)(dev|com)$/i;\n\n/**\n * Converts a frontend API URL into a base64-encoded publishable key.\n *\n * @param frontendApi - The frontend API URL (e.g., 'clerk.example.com').\n * @returns A base64-encoded publishable key with appropriate prefix (pk_live_ or pk_test_).\n */\nexport function buildPublishableKey(frontendApi: string): string {\n  const isDevKey =\n    PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) ||\n    (frontendApi.startsWith('clerk.') && LEGACY_DEV_INSTANCE_SUFFIXES.some(s => frontendApi.endsWith(s)));\n  const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;\n  return `${keyPrefix}${isomorphicBtoa(`${frontendApi}$`)}`;\n}\n\n/**\n * Validates that a decoded publishable key has the correct format.\n * The decoded value should be a frontend API followed by exactly one '$' at the end.\n *\n * @param decoded - The decoded publishable key string to validate.\n * @returns `true` if the decoded key has valid format, `false` otherwise.\n */\nfunction isValidDecodedPublishableKey(decoded: string): boolean {\n  if (!decoded.endsWith('$')) {\n    return false;\n  }\n\n  const withoutTrailing = decoded.slice(0, -1);\n  if (withoutTrailing.includes('$')) {\n    return false;\n  }\n\n  return withoutTrailing.includes('.');\n}\n\nexport function parsePublishableKey(\n  key: string | undefined,\n  options: ParsePublishableKeyOptions & { fatal: true },\n): PublishableKey;\nexport function parsePublishableKey(\n  key: string | undefined,\n  options?: ParsePublishableKeyOptions,\n): PublishableKey | null;\n/**\n * Parses and validates a publishable key, extracting the frontend API and instance type.\n *\n * @param key - The publishable key to parse.\n * @param options - Configuration options for parsing.\n * @param options.fatal\n * @param options.domain\n * @param options.proxyUrl\n * @param options.isSatellite\n * @returns Parsed publishable key object with instanceType and frontendApi, or null if invalid.\n *\n * @throws {Error} When options.fatal is true and key is missing or invalid.\n */\nexport function parsePublishableKey(\n  key: string | undefined,\n  options: { fatal?: boolean; domain?: string; proxyUrl?: string; isSatellite?: boolean } = {},\n): PublishableKey | null {\n  key = key || '';\n\n  if (!key || !isPublishableKey(key)) {\n    if (options.fatal && !key) {\n      throw new Error(\n        'Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys',\n      );\n    }\n    if (options.fatal && !isPublishableKey(key)) {\n      throw new Error('Publishable key not valid.');\n    }\n    return null;\n  }\n\n  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? 'production' : 'development';\n\n  let decodedFrontendApi: string;\n  try {\n    decodedFrontendApi = isomorphicAtob(key.split('_')[2]);\n  } catch {\n    if (options.fatal) {\n      throw new Error('Publishable key not valid: Failed to decode key.');\n    }\n    return null;\n  }\n\n  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {\n    if (options.fatal) {\n      throw new Error('Publishable key not valid: Decoded key has invalid format.');\n    }\n    return null;\n  }\n\n  let frontendApi = decodedFrontendApi.slice(0, -1);\n\n  if (options.proxyUrl) {\n    frontendApi = options.proxyUrl;\n  } else if (instanceType !== 'development' && options.domain && options.isSatellite) {\n    frontendApi = `clerk.${options.domain}`;\n  }\n\n  return {\n    instanceType,\n    frontendApi,\n  };\n}\n\n/**\n * Checks if the provided key is a valid publishable key.\n *\n * @param key - The key to be checked. Defaults to an empty string if not provided.\n * @returns `true` if 'key' is a valid publishable key, `false` otherwise.\n */\nexport function isPublishableKey(key: string = '') {\n  try {\n    const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);\n\n    if (!hasValidPrefix) {\n      return false;\n    }\n\n    const parts = key.split('_');\n    if (parts.length !== 3) {\n      return false;\n    }\n\n    const encodedPart = parts[2];\n    if (!encodedPart) {\n      return false;\n    }\n\n    const decoded = isomorphicAtob(encodedPart);\n    return isValidDecodedPublishableKey(decoded);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Creates a memoized cache for checking if URLs are development or staging environments.\n * Uses a Map to cache results for better performance on repeated checks.\n *\n * @returns An object with an isDevOrStagingUrl method that checks if a URL is dev/staging.\n */\nexport function createDevOrStagingUrlCache() {\n  const devOrStagingUrlCache = new Map<string, boolean>();\n\n  return {\n    /**\n     * Checks if a URL is a development or staging environment.\n     *\n     * @param url - The URL to check (string or URL object).\n     * @returns `true` if the URL is a development or staging environment, `false` otherwise.\n     */\n    isDevOrStagingUrl: (url: string | URL): boolean => {\n      if (!url) {\n        return false;\n      }\n\n      const hostname = typeof url === 'string' ? url : url.hostname;\n      let res = devOrStagingUrlCache.get(hostname);\n      if (res === undefined) {\n        res = DEV_OR_STAGING_SUFFIXES.some(s => hostname.endsWith(s));\n        devOrStagingUrlCache.set(hostname, res);\n      }\n      return res;\n    },\n  };\n}\n\n/**\n * Checks if a publishable key is for a development environment.\n * Supports both legacy format (test_) and new format (pk_test_).\n *\n * @param apiKey - The API key to check.\n * @returns `true` if the key is for development, `false` otherwise.\n */\nexport function isDevelopmentFromPublishableKey(apiKey: string): boolean {\n  return apiKey.startsWith('test_') || apiKey.startsWith('pk_test_');\n}\n\n/**\n * Checks if a publishable key is for a production environment.\n * Supports both legacy format (live_) and new format (pk_live_).\n *\n * @param apiKey - The API key to check.\n * @returns `true` if the key is for production, `false` otherwise.\n */\nexport function isProductionFromPublishableKey(apiKey: string): boolean {\n  return apiKey.startsWith('live_') || apiKey.startsWith('pk_live_');\n}\n\n/**\n * Checks if a secret key is for a development environment.\n * Supports both legacy format (test_) and new format (sk_test_).\n *\n * @param apiKey - The secret key to check.\n * @returns `true` if the key is for development, `false` otherwise.\n */\nexport function isDevelopmentFromSecretKey(apiKey: string): boolean {\n  return apiKey.startsWith('test_') || apiKey.startsWith('sk_test_');\n}\n\n/**\n * Checks if a secret key is for a production environment.\n * Supports both legacy format (live_) and new format (sk_live_).\n *\n * @param apiKey - The secret key to check.\n * @returns `true` if the key is for production, `false` otherwise.\n */\nexport function isProductionFromSecretKey(apiKey: string): boolean {\n  return apiKey.startsWith('live_') || apiKey.startsWith('sk_live_');\n}\n\n/**\n * Generates a unique cookie suffix based on the publishable key using SHA-1 hashing.\n * The suffix is base64-encoded and URL-safe (+ and / characters are replaced).\n *\n * @param publishableKey - The publishable key to generate suffix from.\n * @param subtle - The SubtleCrypto interface to use for hashing (defaults to globalThis.crypto.subtle).\n * @returns A promise that resolves to an 8-character URL-safe base64 string.\n */\nexport async function getCookieSuffix(\n  publishableKey: string,\n  subtle: SubtleCrypto = globalThis.crypto.subtle,\n): Promise<string> {\n  const data = new TextEncoder().encode(publishableKey);\n  const digest = await subtle.digest('sha-1', data);\n  const stringDigest = String.fromCharCode(...new Uint8Array(digest));\n  // Base 64 Encoding with URL and Filename Safe Alphabet: https://datatracker.ietf.org/doc/html/rfc4648#section-5\n  return isomorphicBtoa(stringDigest).replace(/\\+/gi, '-').replace(/\\//gi, '_').substring(0, 8);\n}\n\n/**\n * Creates a suffixed cookie name by appending the cookie suffix to the base name.\n * Used to create unique cookie names based on the publishable key.\n *\n * @param cookieName - The base cookie name.\n * @param cookieSuffix - The suffix to append (typically generated by getCookieSuffix).\n * @returns The suffixed cookie name in format: `${cookieName}_${cookieSuffix}`.\n */\nexport const getSuffixedCookieName = (cookieName: string, cookieSuffix: string): string => {\n  return `${cookieName}_${cookieSuffix}`;\n};\n","/**\n * Convert words to a sentence.\n *\n * @param items - An array of words to be joined.\n * @returns A string with the items joined by a comma and the last item joined by \", or\".\n */\nexport const toSentence = (items: string[]): string => {\n  // TODO: Once Safari supports it, use Intl.ListFormat\n  if (items.length == 0) {\n    return '';\n  }\n  if (items.length == 1) {\n    return items[0];\n  }\n  let sentence = items.slice(0, -1).join(', ');\n  sentence += `, or ${items.slice(-1)}`;\n  return sentence;\n};\n\nconst IP_V4_ADDRESS_REGEX =\n  /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n/**\n * Checks if a string is a valid IPv4 address.\n *\n * @returns True if the string is a valid IPv4 address, false otherwise.\n */\nexport function isIPV4Address(str: string | undefined | null): boolean {\n  return IP_V4_ADDRESS_REGEX.test(str || '');\n}\n\n/**\n * Converts the first character of a string to uppercase.\n *\n * @param str - The string to be converted.\n * @returns The modified string with the rest of the string unchanged.\n *\n * @example\n * ```ts\n * titleize('hello world') // 'Hello world'\n * ```\n */\nexport function titleize(str: string | undefined | null): string {\n  const s = str || '';\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n/**\n * Converts a string from snake_case to camelCase.\n */\nexport function snakeToCamel(str: string | undefined): string {\n  return str ? str.replace(/([-_][a-z])/g, match => match.toUpperCase().replace(/-|_/, '')) : '';\n}\n\n/**\n * Converts a string from camelCase to snake_case.\n */\nexport function camelToSnake(str: string | undefined): string {\n  return str ? str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`) : '';\n}\n\nconst createDeepObjectTransformer = (transform: any) => {\n  const deepTransform = (obj: any): any => {\n    if (!obj) {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(el => {\n        if (typeof el === 'object' || Array.isArray(el)) {\n          return deepTransform(el);\n        }\n        return el;\n      });\n    }\n\n    const copy = { ...obj };\n    const keys = Object.keys(copy);\n    for (const oldName of keys) {\n      const newName = transform(oldName.toString());\n      if (newName !== oldName) {\n        copy[newName] = copy[oldName];\n        delete copy[oldName];\n      }\n      if (typeof copy[newName] === 'object') {\n        copy[newName] = deepTransform(copy[newName]);\n      }\n    }\n    return copy;\n  };\n\n  return deepTransform;\n};\n\n/**\n * Transforms camelCased objects/ arrays to snake_cased.\n * This function recursively traverses all objects and arrays of the passed value\n * camelCased keys are removed.\n *\n * @function\n */\nexport const deepCamelToSnake = createDeepObjectTransformer(camelToSnake);\n\n/**\n * Transforms snake_cased objects/ arrays to camelCased.\n * This function recursively traverses all objects and arrays of the passed value\n * camelCased keys are removed.\n *\n * @function\n */\nexport const deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);\n\n/**\n * A function to determine if a value is truthy.\n *\n * @returns True for `true`, true, positive numbers. False for `false`, false, 0, negative integers and anything else.\n */\nexport function isTruthy(value: unknown): boolean {\n  // Return if Boolean\n  if (typeof value === `boolean`) {\n    return value;\n  }\n\n  // Return false if null or undefined\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  // If the String is true or false\n  if (typeof value === `string`) {\n    if (value.toLowerCase() === `true`) {\n      return true;\n    }\n\n    if (value.toLowerCase() === `false`) {\n      return false;\n    }\n  }\n\n  // Now check if it's a number\n  const number = parseInt(value as string, 10);\n  if (isNaN(number)) {\n    return false;\n  }\n\n  if (number > 0) {\n    return true;\n  }\n\n  // Default to false\n  return false;\n}\n\n/**\n * Get all non-undefined values from an object.\n */\nexport function getNonUndefinedValues<T extends object>(obj: T): Partial<T> {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    if (value !== undefined) {\n      acc[key as keyof T] = value;\n    }\n    return acc;\n  }, {} as Partial<T>);\n}\n","import type { TelemetryEvent } from '@clerk/types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Interface for cache storage used by the telemetry throttler.\n * Implementations can use localStorage, in-memory storage, or any other storage mechanism.\n */\nexport interface ThrottlerCache {\n  getItem(key: string): TtlInMilliseconds | undefined;\n  setItem(key: string, value: TtlInMilliseconds): void;\n  removeItem(key: string): void;\n}\n\n/**\n * Manages throttling for telemetry events using a configurable cache implementation\n * to mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #cache: ThrottlerCache;\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  constructor(cache: ThrottlerCache) {\n    this.#cache = cache;\n  }\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache.getItem(key);\n\n    if (!entry) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    const shouldInvalidate = now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload'] = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n}\n\n/**\n * LocalStorage-based cache implementation for browser environments.\n */\nexport class LocalStorageThrottlerCache implements ThrottlerCache {\n  #storageKey = 'clerk_telemetry_throttler';\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    return this.#getCache()[key];\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    try {\n      const cache = this.#getCache();\n      cache[key] = value;\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && localStorage.length > 0) {\n        // Clear our cache if quota exceeded\n        localStorage.removeItem(this.#storageKey);\n      }\n    }\n  }\n\n  removeItem(key: string): void {\n    try {\n      const cache = this.#getCache();\n      delete cache[key];\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch {\n      // Silently fail if we can't remove\n    }\n  }\n\n  #getCache(): Record<string, TtlInMilliseconds> {\n    try {\n      const cacheString = localStorage.getItem(this.#storageKey);\n      if (!cacheString) {\n        return {};\n      }\n      return JSON.parse(cacheString);\n    } catch {\n      return {};\n    }\n  }\n\n  static isSupported(): boolean {\n    return typeof window !== 'undefined' && !!window.localStorage;\n  }\n}\n\n/**\n * In-memory cache implementation for non-browser environments (e.g., React Native).\n */\nexport class InMemoryThrottlerCache implements ThrottlerCache {\n  #cache: Map<string, TtlInMilliseconds> = new Map();\n  #maxSize = 10000; // Defensive limit to prevent memory issues\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    // Defensive: clear cache if it gets too large\n    if (this.#cache.size > this.#maxSize) {\n      this.#cache.clear();\n      return undefined;\n    }\n\n    return this.#cache.get(key);\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    this.#cache.set(key, value);\n  }\n\n  removeItem(key: string): void {\n    this.#cache.delete(key);\n  }\n}\n","/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:.\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry.\n */\nimport type {\n  InstanceType,\n  SDKMetadata,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n  TelemetryLogEntry,\n} from '@clerk/types';\n\nimport { parsePublishableKey } from '../keys';\nimport { isTruthy } from '../underscore';\nimport { InMemoryThrottlerCache, LocalStorageThrottlerCache, TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\n/**\n * Local interface for window.Clerk to avoid global type pollution.\n * This is only used within this module and doesn't affect other packages.\n */\ninterface WindowWithClerk extends Window {\n  Clerk?: {\n    constructor?: {\n      sdkMetadata?: SDKMetadata;\n    };\n  };\n}\n\n/**\n * Type guard to check if window.Clerk exists and has the expected structure.\n */\nfunction isWindowClerkWithMetadata(clerk: unknown): clerk is { constructor: { sdkMetadata?: SDKMetadata } } {\n  return (\n    typeof clerk === 'object' && clerk !== null && 'constructor' in clerk && typeof clerk.constructor === 'function'\n  );\n}\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize' | 'perEventSampling'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\n/**\n * Structure of log data sent to the telemetry endpoint.\n */\ntype TelemetryLogData = {\n  /** Service that generated the log. */\n  sdk: string;\n  /** The version of the SDK where the event originated from. */\n  sdkv: string;\n  /** The version of Clerk where the event originated from. */\n  cv: string;\n  /** Log level (info, warn, error, debug, etc.). */\n  lvl: TelemetryLogEntry['level'];\n  /** Log message. */\n  msg: string;\n  /** Instance ID - optional. */\n  iid?: string;\n  /** Timestamp when log was generated. */\n  ts: string;\n  /** Primary key. */\n  pk: string | null;\n  /** Additional payload for the log. */\n  payload: Record<string, unknown> | null;\n};\n\ntype TelemetryBufferItem = { kind: 'event'; value: TelemetryEvent } | { kind: 'log'; value: TelemetryLogData };\n\n// Accepted log levels for runtime validation\nconst VALID_LOG_LEVELS = new Set<string>(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryBufferItem[] = [];\n  #pendingFlush: number | ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdk = options.sdk!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    // Use LocalStorage cache in browsers where it's supported, otherwise fall back to in-memory cache\n    const cache = LocalStorageThrottlerCache.isSupported()\n      ? new LocalStorageThrottlerCache()\n      : new InMemoryThrottlerCache();\n    this.#eventThrottler = new TelemetryEventThrottler(cache);\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (\n      this.#config.disabled ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))\n    ) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return (\n      this.#config.debug ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG))\n    );\n  }\n\n  record(event: TelemetryEventRaw): void {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n      this.#logEvent(preparedPayload.event, preparedPayload);\n\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n\n      this.#buffer.push({ kind: 'event', value: preparedPayload });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry event', error);\n    }\n  }\n\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry: TelemetryLogEntry): void {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n\n      const levelIsValid = typeof entry?.level === 'string' && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === 'string' && entry.message.trim().length > 0;\n\n      let normalizedTimestamp: Date | null = null;\n      const timestampInput: unknown = (entry as unknown as { timestamp?: unknown })?.timestamp;\n      if (typeof timestampInput === 'number' || typeof timestampInput === 'string') {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== 'undefined') {\n          console.warn('[clerk/telemetry] Dropping invalid telemetry log entry', {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null,\n          });\n        }\n        return;\n      }\n\n      const sdkMetadata = this.#getSDKMetadata();\n\n      const logData: TelemetryLogData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? '',\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context),\n      };\n\n      this.#buffer.push({ kind: 'log', value: logData });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry log entry', error);\n    }\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldRecordLog(_entry: TelemetryLogEntry): boolean {\n    // Always allow logs from debug logger to be sent. Debug logger itself is already gated elsewhere.\n    return true;\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    const toBeSampled =\n      randomSeed <= this.#config.samplingRate &&\n      (this.#config.perEventSampling === false ||\n        typeof eventSamplingRate === 'undefined' ||\n        randomSeed <= eventSamplingRate);\n\n    if (!toBeSampled) {\n      return false;\n    }\n\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== 'undefined') {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) {\n      return;\n    }\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    // Capture the current buffer and clear it immediately to avoid closure references\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n\n    this.#pendingFlush = null;\n\n    if (itemsToSend.length === 0) {\n      return;\n    }\n\n    const eventsToSend = itemsToSend\n      .filter(item => item.kind === 'event')\n      .map(item => (item as { kind: 'event'; value: TelemetryEvent }).value);\n\n    const logsToSend = itemsToSend\n      .filter(item => item.kind === 'log')\n      .map(item => (item as { kind: 'log'; value: TelemetryLogData }).value);\n\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL('/v1/event', this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend }),\n      }).catch(() => void 0);\n    }\n\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL('/v1/logs', this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        body: JSON.stringify({ logs: logsToSend }),\n      }).catch(() => void 0);\n    }\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    if (typeof window !== 'undefined') {\n      const windowWithClerk = window as WindowWithClerk;\n\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n\n          if (name !== undefined) {\n            sdkMetadata.name = name;\n          }\n          if (version !== undefined) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context: unknown): Record<string, unknown> | null {\n    if (context === null || typeof context === 'undefined') {\n      return null;\n    }\n    if (typeof context !== 'object') {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === 'object' && !Array.isArray(cleaned)) {\n        return cleaned as Record<string, unknown>;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED';\nconst EVENT_COMPONENT_OPENED = 'COMPONENT_OPENED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\n/** Increase sampling for high-signal auth components on mount. */\nconst AUTH_COMPONENTS = new Set<string>(['SignIn', 'SignUp']);\n\n/**\n * Returns the per-event sampling rate for component-mounted telemetry events.\n * Uses a higher rate for SignIn/SignUp to improve signal quality.\n *\n *  @internal\n */\nfunction getComponentMountedSamplingRate(component: string): number {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE;\n}\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponent = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & TelemetryEventRaw['payload'];\n\n/**\n * Factory for prebuilt component telemetry events.\n *\n * @internal\n */\nfunction createPrebuiltComponentEvent(event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED) {\n  return function (\n    component: string,\n    props?: Record<string, any>,\n    additionalPayload?: TelemetryEventRaw['payload'],\n  ): TelemetryEventRaw<EventPrebuiltComponent> {\n    return {\n      event,\n      eventSamplingRate:\n        event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload,\n      },\n    };\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n */\nexport function eventPrebuiltComponentOpened(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: TelemetryEventRaw['payload'] = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_METHOD_CALLED = 'METHOD_CALLED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventMethodCalled = {\n  method: string;\n} & Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventMethodCalled(\n  method: string,\n  payload?: Record<string, unknown>,\n): TelemetryEventRaw<EventMethodCalled> {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      method,\n      ...payload,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_FRAMEWORK_METADATA = 'FRAMEWORK_METADATA';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventFrameworkMetadata = Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventFrameworkMetadata(payload: EventFrameworkMetadata): TelemetryEventRaw<EventFrameworkMetadata> {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n","import type { Appearance, BaseTheme, TelemetryEventRaw } from '@clerk/types';\n\nexport const EVENT_THEME_USAGE = 'THEME_USAGE';\nexport const EVENT_SAMPLING_RATE = 1;\n\ntype EventThemeUsage = {\n  /**\n   * The name of the theme being used (e.g., \"shadcn\", \"neobrutalism\", etc.).\n   */\n  themeName?: string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n *\n * @param appearance - The appearance prop from ClerkProvider.\n * @example\n * telemetry.record(eventThemeUsage(appearance));\n */\nexport function eventThemeUsage(appearance?: Appearance): TelemetryEventRaw<EventThemeUsage> {\n  const payload = analyzeThemeUsage(appearance);\n\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n\n/**\n * Analyzes the appearance prop to extract theme usage information for telemetry.\n *\n * @internal\n */\nfunction analyzeThemeUsage(appearance?: Appearance): EventThemeUsage {\n  if (!appearance || typeof appearance !== 'object') {\n    return {};\n  }\n\n  // Prioritize the new theme property over deprecated baseTheme\n  const themeProperty = appearance.theme || appearance.baseTheme;\n\n  if (!themeProperty) {\n    return {};\n  }\n\n  let themeName: string | undefined;\n\n  if (Array.isArray(themeProperty)) {\n    // Look for the first identifiable theme name in the array\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n\n  return { themeName };\n}\n\n/**\n * Extracts the theme name from a theme object.\n *\n * @internal\n */\nfunction extractThemeName(theme: BaseTheme): string | undefined {\n  if (typeof theme === 'string') {\n    return theme;\n  }\n\n  if (typeof theme === 'object' && theme !== null) {\n    // Check for explicit theme name\n    if ('name' in theme && typeof theme.name === 'string') {\n      return theme.name;\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,6BAAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACIO,IAAM,iBAAiB,CAAC,SAAiB;AAC9C,MAAI,OAAO,SAAS,eAAe,OAAO,SAAS,YAAY;AAC7D,WAAO,KAAK,IAAI;AAAA,EAClB,WAAW,OAAO,WAAW,eAAe,OAAO,QAAQ;AACzD,WAAO,IAAI,OAAO,OAAO,MAAM,QAAQ,EAAE,SAAS;AAAA,EACpD;AACA,SAAO;AACT;;;ACUA,IAAM,8BAA8B;AAGpC,IAAM,8BAA8B;AA6BpC,SAAS,6BAA6B,SAA0B;AAC9D,MAAI,CAAC,QAAQ,SAAS,GAAG,GAAG;AAC1B,WAAO;AAAA,EACT;AAEA,QAAM,kBAAkB,QAAQ,MAAM,GAAG,EAAE;AAC3C,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,SAAO,gBAAgB,SAAS,GAAG;AACrC;AAuBO,SAAS,oBACd,KACA,UAA0F,CAAC,GACpE;AACvB,QAAM,OAAO;AAEb,MAAI,CAAC,OAAO,CAAC,iBAAiB,GAAG,GAAG;AAClC,QAAI,QAAQ,SAAS,CAAC,KAAK;AACzB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,QAAI,QAAQ,SAAS,CAAC,iBAAiB,GAAG,GAAG;AAC3C,YAAM,IAAI,MAAM,4BAA4B;AAAA,IAC9C;AACA,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,IAAI,WAAW,2BAA2B,IAAI,eAAe;AAElF,MAAI;AACJ,MAAI;AACF,yBAAqB,eAAe,IAAI,MAAM,GAAG,EAAE,CAAC,CAAC;AAAA,EACvD,QAAQ;AACN,QAAI,QAAQ,OAAO;AACjB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AACA,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,6BAA6B,kBAAkB,GAAG;AACrD,QAAI,QAAQ,OAAO;AACjB,YAAM,IAAI,MAAM,4DAA4D;AAAA,IAC9E;AACA,WAAO;AAAA,EACT;AAEA,MAAI,cAAc,mBAAmB,MAAM,GAAG,EAAE;AAEhD,MAAI,QAAQ,UAAU;AACpB,kBAAc,QAAQ;AAAA,EACxB,WAAW,iBAAiB,iBAAiB,QAAQ,UAAU,QAAQ,aAAa;AAClF,kBAAc,SAAS,QAAQ,MAAM;AAAA,EACvC;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAQO,SAAS,iBAAiB,MAAc,IAAI;AACjD,MAAI;AACF,UAAM,iBAAiB,IAAI,WAAW,2BAA2B,KAAK,IAAI,WAAW,2BAA2B;AAEhH,QAAI,CAAC,gBAAgB;AACnB,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,QAAI,MAAM,WAAW,GAAG;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,cAAc,MAAM,CAAC;AAC3B,QAAI,CAAC,aAAa;AAChB,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,eAAe,WAAW;AAC1C,WAAO,6BAA6B,OAAO;AAAA,EAC7C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;;;ACrHO,SAAS,aAAa,KAAiC;AAC5D,SAAO,MAAM,IAAI,QAAQ,gBAAgB,WAAS,MAAM,YAAY,EAAE,QAAQ,OAAO,EAAE,CAAC,IAAI;AAC9F;AAKO,SAAS,aAAa,KAAiC;AAC5D,SAAO,MAAM,IAAI,QAAQ,UAAU,YAAU,IAAI,OAAO,YAAY,CAAC,EAAE,IAAI;AAC7E;AAEA,IAAM,8BAA8B,CAAC,cAAmB;AACtD,QAAM,gBAAgB,CAAC,QAAkB;AACvC,QAAI,CAAC,KAAK;AACR,aAAO;AAAA,IACT;AAEA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAO,IAAI,IAAI,QAAM;AACnB,YAAI,OAAO,OAAO,YAAY,MAAM,QAAQ,EAAE,GAAG;AAC/C,iBAAO,cAAc,EAAE;AAAA,QACzB;AACA,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAEA,UAAM,OAAO,EAAE,GAAG,IAAI;AACtB,UAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,eAAW,WAAW,MAAM;AAC1B,YAAM,UAAU,UAAU,QAAQ,SAAS,CAAC;AAC5C,UAAI,YAAY,SAAS;AACvB,aAAK,OAAO,IAAI,KAAK,OAAO;AAC5B,eAAO,KAAK,OAAO;AAAA,MACrB;AACA,UAAI,OAAO,KAAK,OAAO,MAAM,UAAU;AACrC,aAAK,OAAO,IAAI,cAAc,KAAK,OAAO,CAAC;AAAA,MAC7C;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AASO,IAAM,mBAAmB,4BAA4B,YAAY;AASjE,IAAM,mBAAmB,4BAA4B,YAAY;AAOjE,SAAS,SAAS,OAAyB;AAEhD,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,UAAa,UAAU,MAAM;AACzC,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,MAAM,YAAY,MAAM,QAAQ;AAClC,aAAO;AAAA,IACT;AAEA,QAAI,MAAM,YAAY,MAAM,SAAS;AACnC,aAAO;AAAA,IACT;AAAA,EACF;AAGA,QAAM,SAAS,SAAS,OAAiB,EAAE;AAC3C,MAAI,MAAM,MAAM,GAAG;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,SAAS,GAAG;AACd,WAAO;AAAA,EACT;AAGA,SAAO;AACT;;;ACnJA,IAAM,uBAAuB;AAgBtB,IAAM,0BAAN,MAA8B;AAAA,EACnC;AAAA,EACA,YAAY;AAAA,EAEZ,YAAY,OAAuB;AACjC,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,iBAAiB,SAAkC;AACjD,UAAM,MAAM,KAAK,IAAI;AACrB,UAAM,MAAM,KAAK,aAAa,OAAO;AACrC,UAAM,QAAQ,KAAK,OAAO,QAAQ,GAAG;AAErC,QAAI,CAAC,OAAO;AACV,WAAK,OAAO,QAAQ,KAAK,GAAG;AAC5B,aAAO;AAAA,IACT;AAEA,UAAM,mBAAmB,MAAM,QAAQ,KAAK;AAC5C,QAAI,kBAAkB;AACpB,WAAK,OAAO,QAAQ,KAAK,GAAG;AAC5B,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,OAA+B;AAC1C,UAAM,EAAE,IAAI,KAAK,IAAI,KAAK,SAAS,GAAG,KAAK,IAAI;AAE/C,UAAM,iBAA4F;AAAA,MAChG,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAEA,WAAO,KAAK;AAAA,MACV,OAAO,KAAK;AAAA,QACV,GAAG;AAAA,QACH,GAAG;AAAA,MACL,CAAC,EACE,KAAK,EACL,IAAI,SAAO,eAAe,GAAG,CAAC;AAAA,IACnC;AAAA,EACF;AACF;AAKO,IAAM,6BAAN,MAA2D;AAAA,EAChE,cAAc;AAAA,EAEd,QAAQ,KAA4C;AAClD,WAAO,KAAK,UAAU,EAAE,GAAG;AAAA,EAC7B;AAAA,EAEA,QAAQ,KAAa,OAAgC;AACnD,QAAI;AACF,YAAM,QAAQ,KAAK,UAAU;AAC7B,YAAM,GAAG,IAAI;AACb,mBAAa,QAAQ,KAAK,aAAa,KAAK,UAAU,KAAK,CAAC;AAAA,IAC9D,SAAS,KAAc;AACrB,YAAM,uBACJ,eAAe;AAAA,OAEd,IAAI,SAAS,wBAAwB,IAAI,SAAS;AAErD,UAAI,wBAAwB,aAAa,SAAS,GAAG;AAEnD,qBAAa,WAAW,KAAK,WAAW;AAAA,MAC1C;AAAA,IACF;AAAA,EACF;AAAA,EAEA,WAAW,KAAmB;AAC5B,QAAI;AACF,YAAM,QAAQ,KAAK,UAAU;AAC7B,aAAO,MAAM,GAAG;AAChB,mBAAa,QAAQ,KAAK,aAAa,KAAK,UAAU,KAAK,CAAC;AAAA,IAC9D,QAAQ;AAAA,IAER;AAAA,EACF;AAAA,EAEA,YAA+C;AAC7C,QAAI;AACF,YAAM,cAAc,aAAa,QAAQ,KAAK,WAAW;AACzD,UAAI,CAAC,aAAa;AAChB,eAAO,CAAC;AAAA,MACV;AACA,aAAO,KAAK,MAAM,WAAW;AAAA,IAC/B,QAAQ;AACN,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA,EAEA,OAAO,cAAuB;AAC5B,WAAO,OAAO,WAAW,eAAe,CAAC,CAAC,OAAO;AAAA,EACnD;AACF;AAKO,IAAM,yBAAN,MAAuD;AAAA,EAC5D,SAAyC,oBAAI,IAAI;AAAA,EACjD,WAAW;AAAA;AAAA,EAEX,QAAQ,KAA4C;AAElD,QAAI,KAAK,OAAO,OAAO,KAAK,UAAU;AACpC,WAAK,OAAO,MAAM;AAClB,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,OAAO,IAAI,GAAG;AAAA,EAC5B;AAAA,EAEA,QAAQ,KAAa,OAAgC;AACnD,SAAK,OAAO,IAAI,KAAK,KAAK;AAAA,EAC5B;AAAA,EAEA,WAAW,KAAmB;AAC5B,SAAK,OAAO,OAAO,GAAG;AAAA,EACxB;AACF;;;AC5GA,SAAS,0BAA0B,OAAyE;AAC1G,SACE,OAAO,UAAU,YAAY,UAAU,QAAQ,iBAAiB,SAAS,OAAO,MAAM,gBAAgB;AAE1G;AA6CA,IAAM,mBAAmB,oBAAI,IAAY,CAAC,SAAS,QAAQ,QAAQ,SAAS,OAAO,CAAC;AAEpF,IAAM,iBAAoD;AAAA,EACxD,cAAc;AAAA,EACd,eAAe;AAAA;AAAA;AAAA;AAAA,EAIf,UAAU;AACZ;AAEO,IAAM,qBAAN,MAAgE;AAAA,EACrE;AAAA,EACA;AAAA,EACA,YAA+B,CAAC;AAAA,EAChC,UAAiC,CAAC;AAAA,EAClC,gBAA+D;AAAA,EAE/D,YAAY,SAAoC;AAC9C,SAAK,UAAU;AAAA,MACb,eAAe,QAAQ,iBAAiB,eAAe;AAAA,MACvD,cAAc,QAAQ,gBAAgB,eAAe;AAAA,MACrD,kBAAkB,QAAQ,oBAAoB;AAAA,MAC9C,UAAU,QAAQ,YAAY;AAAA,MAC9B,OAAO,QAAQ,SAAS;AAAA,MACxB,UAAU,eAAe;AAAA,IAC3B;AAEA,QAAI,CAAC,QAAQ,gBAAgB,OAAO,WAAW,aAAa;AAE1D,WAAK,UAAU,eAAe;AAAA,IAChC,OAAO;AACL,WAAK,UAAU,eAAe,QAAQ,gBAAgB;AAAA,IACxD;AAIA,SAAK,UAAU,MAAM,QAAQ;AAE7B,SAAK,UAAU,aAAa,QAAQ;AAEpC,SAAK,UAAU,iBAAiB,QAAQ,kBAAkB;AAE1D,UAAM,YAAY,oBAAoB,QAAQ,cAAc;AAC5D,QAAI,WAAW;AACb,WAAK,UAAU,eAAe,UAAU;AAAA,IAC1C;AAEA,QAAI,QAAQ,WAAW;AAErB,WAAK,UAAU,YAAY,QAAQ,UAAU,UAAU,GAAG,EAAE;AAAA,IAC9D;AAGA,UAAM,QAAQ,2BAA2B,YAAY,IACjD,IAAI,2BAA2B,IAC/B,IAAI,uBAAuB;AAC/B,SAAK,kBAAkB,IAAI,wBAAwB,KAAK;AAAA,EAC1D;AAAA,EAEA,IAAI,YAAqB;AACvB,QAAI,KAAK,UAAU,iBAAiB,eAAe;AACjD,aAAO;AAAA,IACT;AAIA,QACE,KAAK,QAAQ,YACZ,OAAO,YAAY,eAAe,QAAQ,OAAO,SAAS,QAAQ,IAAI,wBAAwB,GAC/F;AACA,aAAO;AAAA,IACT;AAKA,QAAI,OAAO,WAAW,eAAe,CAAC,CAAC,QAAQ,WAAW,WAAW;AACnE,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,UAAmB;AACrB,WACE,KAAK,QAAQ,SACZ,OAAO,YAAY,eAAe,QAAQ,OAAO,SAAS,QAAQ,IAAI,qBAAqB;AAAA,EAEhG;AAAA,EAEA,OAAO,OAAgC;AACrC,QAAI;AACF,YAAM,kBAAkB,KAAK,gBAAgB,MAAM,OAAO,MAAM,OAAO;AAEvE,WAAK,UAAU,gBAAgB,OAAO,eAAe;AAErD,UAAI,CAAC,KAAK,cAAc,iBAAiB,MAAM,iBAAiB,GAAG;AACjE;AAAA,MACF;AAEA,WAAK,QAAQ,KAAK,EAAE,MAAM,SAAS,OAAO,gBAAgB,CAAC;AAE3D,WAAK,eAAe;AAAA,IACtB,SAAS,OAAO;AACd,cAAQ,MAAM,qDAAqD,KAAK;AAAA,IAC1E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,OAAgC;AACxC,QAAI;AACF,UAAI,CAAC,KAAK,iBAAiB,KAAK,GAAG;AACjC;AAAA,MACF;AAEA,YAAM,eAAe,OAAO,OAAO,UAAU,YAAY,iBAAiB,IAAI,MAAM,KAAK;AACzF,YAAM,iBAAiB,OAAO,OAAO,YAAY,YAAY,MAAM,QAAQ,KAAK,EAAE,SAAS;AAE3F,UAAI,sBAAmC;AACvC,YAAM,iBAA2B,OAA8C;AAC/E,UAAI,OAAO,mBAAmB,YAAY,OAAO,mBAAmB,UAAU;AAC5E,cAAM,YAAY,IAAI,KAAK,cAAc;AACzC,YAAI,CAAC,OAAO,MAAM,UAAU,QAAQ,CAAC,GAAG;AACtC,gCAAsB;AAAA,QACxB;AAAA,MACF;AAEA,UAAI,CAAC,gBAAgB,CAAC,kBAAkB,wBAAwB,MAAM;AACpE,YAAI,KAAK,WAAW,OAAO,YAAY,aAAa;AAClD,kBAAQ,KAAK,0DAA0D;AAAA,YACrE;AAAA,YACA;AAAA,YACA,kBAAkB,wBAAwB;AAAA,UAC5C,CAAC;AAAA,QACH;AACA;AAAA,MACF;AAEA,YAAM,cAAc,KAAK,gBAAgB;AAEzC,YAAM,UAA4B;AAAA,QAChC,KAAK,YAAY;AAAA,QACjB,MAAM,YAAY;AAAA,QAClB,IAAI,KAAK,UAAU,gBAAgB;AAAA,QACnC,KAAK,MAAM;AAAA,QACX,KAAK,MAAM;AAAA,QACX,IAAI,oBAAoB,YAAY;AAAA,QACpC,IAAI,KAAK,UAAU,kBAAkB;AAAA,QACrC,SAAS,KAAK,iBAAiB,MAAM,OAAO;AAAA,MAC9C;AAEA,WAAK,QAAQ,KAAK,EAAE,MAAM,OAAO,OAAO,QAAQ,CAAC;AAEjD,WAAK,eAAe;AAAA,IACtB,SAAS,OAAO;AACd,cAAQ,MAAM,yDAAyD,KAAK;AAAA,IAC9E;AAAA,EACF;AAAA,EAEA,cAAc,iBAAiC,mBAA4B;AACzE,WAAO,KAAK,aAAa,CAAC,KAAK,WAAW,KAAK,iBAAiB,iBAAiB,iBAAiB;AAAA,EACpG;AAAA,EAEA,iBAAiB,QAAoC;AAEnD,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,iBAAiC,mBAA4B;AAC5E,UAAM,aAAa,KAAK,OAAO;AAE/B,UAAM,cACJ,cAAc,KAAK,QAAQ,iBAC1B,KAAK,QAAQ,qBAAqB,SACjC,OAAO,sBAAsB,eAC7B,cAAc;AAElB,QAAI,CAAC,aAAa;AAChB,aAAO;AAAA,IACT;AAEA,WAAO,CAAC,KAAK,gBAAgB,iBAAiB,eAAe;AAAA,EAC/D;AAAA,EAEA,iBAAuB;AAErB,QAAI,OAAO,WAAW,aAAa;AACjC,WAAK,OAAO;AACZ;AAAA,IACF;AACA,UAAM,eAAe,KAAK,QAAQ,UAAU,KAAK,QAAQ;AACzD,QAAI,cAAc;AAGhB,UAAI,KAAK,eAAe;AACtB,YAAI,OAAO,uBAAuB,aAAa;AAC7C,6BAAmB,OAAO,KAAK,aAAa,CAAC;AAAA,QAC/C,OAAO;AACL,uBAAa,OAAO,KAAK,aAAa,CAAC;AAAA,QACzC;AAAA,MACF;AACA,WAAK,OAAO;AACZ;AAAA,IACF;AAGA,QAAI,KAAK,eAAe;AACtB;AAAA,IACF;AAEA,QAAI,yBAAyB,QAAQ;AACnC,WAAK,gBAAgB,oBAAoB,MAAM;AAC7C,aAAK,OAAO;AACZ,aAAK,gBAAgB;AAAA,MACvB,CAAC;AAAA,IACH,OAAO;AAEL,WAAK,gBAAgB,WAAW,MAAM;AACpC,aAAK,OAAO;AACZ,aAAK,gBAAgB;AAAA,MACvB,GAAG,CAAC;AAAA,IACN;AAAA,EACF;AAAA,EAEA,SAAe;AAEb,UAAM,cAAc,CAAC,GAAG,KAAK,OAAO;AACpC,SAAK,UAAU,CAAC;AAEhB,SAAK,gBAAgB;AAErB,QAAI,YAAY,WAAW,GAAG;AAC5B;AAAA,IACF;AAEA,UAAM,eAAe,YAClB,OAAO,UAAQ,KAAK,SAAS,OAAO,EACpC,IAAI,UAAS,KAAkD,KAAK;AAEvE,UAAM,aAAa,YAChB,OAAO,UAAQ,KAAK,SAAS,KAAK,EAClC,IAAI,UAAS,KAAkD,KAAK;AAEvE,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,YAAY,IAAI,IAAI,aAAa,KAAK,QAAQ,QAAQ;AAC5D,YAAM,WAAW;AAAA,QACf,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,WAAW;AAAA,QACX,QAAQ;AAAA;AAAA,QAER,MAAM,KAAK,UAAU,EAAE,QAAQ,aAAa,CAAC;AAAA,MAC/C,CAAC,EAAE,MAAM,MAAM,MAAM;AAAA,IACvB;AAEA,QAAI,WAAW,SAAS,GAAG;AACzB,YAAM,UAAU,IAAI,IAAI,YAAY,KAAK,QAAQ,QAAQ;AACzD,YAAM,SAAS;AAAA,QACb,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,MAAM,KAAK,UAAU,EAAE,MAAM,WAAW,CAAC;AAAA,MAC3C,CAAC,EAAE,MAAM,MAAM,MAAM;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,OAAgC,SAA8B;AACtE,QAAI,CAAC,KAAK,SAAS;AACjB;AAAA,IACF;AAEA,QAAI,OAAO,QAAQ,mBAAmB,aAAa;AACjD,cAAQ,eAAe,qBAAqB,KAAK;AACjD,cAAQ,IAAI,OAAO;AACnB,cAAQ,SAAS;AAAA,IACnB,OAAO;AACL,cAAQ,IAAI,qBAAqB,OAAO,OAAO;AAAA,IACjD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,kBAAkB;AAChB,UAAM,cAAc;AAAA,MAClB,MAAM,KAAK,UAAU;AAAA,MACrB,SAAS,KAAK,UAAU;AAAA,IAC1B;AAEA,QAAI,OAAO,WAAW,aAAa;AACjC,YAAM,kBAAkB;AAExB,UAAI,gBAAgB,OAAO;AACzB,cAAM,cAAc,gBAAgB;AAEpC,YAAI,0BAA0B,WAAW,KAAK,YAAY,YAAY,aAAa;AACjF,gBAAM,EAAE,MAAM,QAAQ,IAAI,YAAY,YAAY;AAElD,cAAI,SAAS,QAAW;AACtB,wBAAY,OAAO;AAAA,UACrB;AACA,cAAI,YAAY,QAAW;AACzB,wBAAY,UAAU;AAAA,UACxB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,OAAgC,SAAoD;AAClG,UAAM,cAAc,KAAK,gBAAgB;AAEzC,WAAO;AAAA,MACL;AAAA,MACA,IAAI,KAAK,UAAU,gBAAgB;AAAA,MACnC,IAAI,KAAK,UAAU,gBAAgB;AAAA,MACnC,KAAK,YAAY;AAAA,MACjB,MAAM,YAAY;AAAA,MAClB,GAAI,KAAK,UAAU,iBAAiB,EAAE,IAAI,KAAK,UAAU,eAAe,IAAI,CAAC;AAAA,MAC7E,GAAI,KAAK,UAAU,YAAY,EAAE,IAAI,KAAK,UAAU,UAAU,IAAI,CAAC;AAAA,MACnE;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,SAAkD;AACjE,QAAI,YAAY,QAAQ,OAAO,YAAY,aAAa;AACtD,aAAO;AAAA,IACT;AACA,QAAI,OAAO,YAAY,UAAU;AAC/B,aAAO;AAAA,IACT;AACA,QAAI;AACF,YAAM,UAAU,KAAK,MAAM,KAAK,UAAU,OAAO,CAAC;AAClD,UAAI,WAAW,OAAO,YAAY,YAAY,CAAC,MAAM,QAAQ,OAAO,GAAG;AACrE,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;ACncA,IAAM,0BAA0B;AAChC,IAAM,yBAAyB;AAC/B,IAAM,sBAAsB;AAG5B,IAAM,kBAAkB,oBAAI,IAAY,CAAC,UAAU,QAAQ,CAAC;AAQ5D,SAAS,gCAAgC,WAA2B;AAClE,SAAO,gBAAgB,IAAI,SAAS,IAAI,IAAI;AAC9C;AAoBA,SAAS,6BAA6B,OAAuE;AAC3G,SAAO,SACL,WACA,OACA,mBAC2C;AAC3C,WAAO;AAAA,MACL;AAAA,MACA,mBACE,UAAU,0BAA0B,gCAAgC,SAAS,IAAI;AAAA,MACnF,SAAS;AAAA,QACP;AAAA,QACA,gBAAgB,QAAQ,OAAO,UAAU;AAAA,QACzC,WAAW,QAAQ,OAAO,YAAY,SAAS;AAAA,QAC/C,UAAU,QAAQ,OAAO,YAAY,QAAQ;AAAA,QAC7C,WAAW,QAAQ,OAAO,YAAY,SAAS;AAAA,QAC/C,GAAG;AAAA,MACL;AAAA,IACF;AAAA,EACF;AACF;AAWO,SAAS,8BACd,WACA,OACA,mBAC2C;AAC3C,SAAO,6BAA6B,uBAAuB,EAAE,WAAW,OAAO,iBAAiB;AAClG;AAWO,SAAS,6BACd,WACA,OACA,mBAC2C;AAC3C,SAAO,6BAA6B,sBAAsB,EAAE,WAAW,OAAO,iBAAiB;AACjG;AAYO,SAAS,sBACd,WACA,QAAsC,CAAC,GACG;AAC1C,SAAO;AAAA,IACL,OAAO;AAAA,IACP,mBAAmB,gCAAgC,SAAS;AAAA,IAC5D,SAAS;AAAA,MACP;AAAA,MACA,GAAG;AAAA,IACL;AAAA,EACF;AACF;;;ACjHA,IAAM,sBAAsB;AAC5B,IAAMC,uBAAsB;AASrB,SAAS,kBACd,QACA,SACsC;AACtC,SAAO;AAAA,IACL,OAAO;AAAA,IACP,mBAAmBA;AAAA,IACnB,SAAS;AAAA,MACP;AAAA,MACA,GAAG;AAAA,IACL;AAAA,EACF;AACF;;;ACtBA,IAAM,2BAA2B;AACjC,IAAMC,uBAAsB;AAOrB,SAAS,uBAAuB,SAA4E;AACjH,SAAO;AAAA,IACL,OAAO;AAAA,IACP,mBAAmBA;AAAA,IACnB;AAAA,EACF;AACF;;;ACdO,IAAM,oBAAoB;AAC1B,IAAMC,uBAAsB;AAgB5B,SAAS,gBAAgB,YAA6D;AAC3F,QAAM,UAAU,kBAAkB,UAAU;AAE5C,SAAO;AAAA,IACL,OAAO;AAAA,IACP,mBAAmBA;AAAA,IACnB;AAAA,EACF;AACF;AAOA,SAAS,kBAAkB,YAA0C;AACnE,MAAI,CAAC,cAAc,OAAO,eAAe,UAAU;AACjD,WAAO,CAAC;AAAA,EACV;AAGA,QAAM,gBAAgB,WAAW,SAAS,WAAW;AAErD,MAAI,CAAC,eAAe;AAClB,WAAO,CAAC;AAAA,EACV;AAEA,MAAI;AAEJ,MAAI,MAAM,QAAQ,aAAa,GAAG;AAEhC,eAAW,SAAS,eAAe;AACjC,YAAM,OAAO,iBAAiB,KAAK;AACnC,UAAI,MAAM;AACR,oBAAY;AACZ;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AACL,gBAAY,iBAAiB,aAAa;AAAA,EAC5C;AAEA,SAAO,EAAE,UAAU;AACrB;AAOA,SAAS,iBAAiB,OAAsC;AAC9D,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAE/C,QAAI,UAAU,SAAS,OAAO,MAAM,SAAS,UAAU;AACrD,aAAO,MAAM;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;","names":["EVENT_SAMPLING_RATE","EVENT_SAMPLING_RATE","EVENT_SAMPLING_RATE","EVENT_SAMPLING_RATE"]}